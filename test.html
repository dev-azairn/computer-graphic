<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformation Velocity Field (Stroke)</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        .controls button {
            margin-top: 5px;
            padding: 5px 10px;
        }
    </style>
</head>
<body>
    <div class="controls" name="">
        <label for="speed">Speed</label>
        <input type="range" id="speed" min="-100" max="100" value="0" step="1"/>
        <output id="speedValue">0</output><span> px/s (or deg/s)</span>
        <br/>
        <label for="orientation">Orientation</label>
        <input type="range" id="orientation" min="0" max="360" value="0" step="1"/>
        <output id="orientationValue"> 0</output><span>deg</span>
        <br/>
        <button type="button" id="translateBtn">Translate Mode</button>
        <button type="button" id="rotateBtn">Rotate Mode</button>
        <button type="button" id="scaleBtn">ScaleMode</button>
        <button type="button" id="origin">Reset Position</button>
        <button type="button" id="resetBtn">Reset Drawing</button>
    </div>
    <p>Frame Rate: <span id="fps"></span></p>
    <canvas id="myCanvas" width="500" height="300"></canvas>
    <script>
        
        // --- Initialization and Global Variables ---
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");
        const speedInput = document.getElementById("speed");
        const orientationInput = document.getElementById("orientation");
        const outputSpeed = document.getElementById("speedValue");
        const outputOrient = document.getElementById("orientationValue");
        const translateBtn = document.getElementById("translateBtn");
        const rotateBtn = document.getElementById("rotateBtn");
        const scaleBtn = document.getElementById("scaleBtn");
        const resetBtn = document.getElementById("resetBtn");
        const originInput = document.getElementById("origin");
        const fpsBlock = document.getElementById("fps");

        let points = [];        // Current shape points
        let savePosition = null; // Original shape points
        let hasDrawing = false;
        let speedValue = parseFloat(speedInput.value);
        let orientationValue = parseFloat(orientationInput.value);
        let mode = 'none';      // 'drawing', 'translate', 'rotate', 'scale', or 'none'

        // Global Constants for Visualization
        const DEGREES_TO_RADIANS = Math.PI / 180;
        const TIME_FACTOR = 1;      // Arrows show displacement over 1 second
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;


        // --- Event Listeners and Mode Toggles ---

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            if(hasDrawing) return;

            if (mode == 'none') {
                points = [{x, y}];
                mode = 'drawing';
                ctx.fillRect(x - 2, y - 2, 4, 4)
            }

            const distance = Math.sqrt((x - points[0].x) ** 2 + (y - points[0].y) ** 2)
            if (distance <= 10 && points.length >= 2){
                points.push({x: points[0].x, y: points[0].y});
                savePosition = [...points];
                drawShape();
                hasDrawing = true;
                mode = 'none'
            } else {
                points.push({x, y});
                drawLines();
            }
        });
        
        speedInput.addEventListener('input', (event) => {
            speedValue = parseFloat(event.target.value);
            outputSpeed.textContent = speedValue;
        });

        orientationInput.addEventListener('input', (event) => {
            orientationValue = parseFloat(event.target.value);
            outputOrient.textContent = orientationValue;
        });
        
        resetBtn.addEventListener('click', () => {
            ctx.clearRect(0,0, CANVAS_WIDTH, CANVAS_HEIGHT);
            points = [];
            savePosition = null;
            hasDrawing = false;
            mode = 'none';
            translateBtn.style.backgroundColor = '';
            rotateBtn.style.backgroundColor = '';
            scaleBtn.style.backgroundColor = '';
        });

        originInput.addEventListener('click', () => {
            mode = 'none';
            if (savePosition) {
                points = [...savePosition];
                drawShape();
                translateBtn.style.backgroundColor = '';
                rotateBtn.style.backgroundColor = '';
                scaleBtn.style.backgroundColor = '';
            }
        });

        function setMode(newMode, button) {
            if (!hasDrawing && newMode !== 'drawing') return;
            
            if (mode === newMode) {
                mode = 'none';
                button.style.backgroundColor = '';
                return;
            }
            
            translateBtn.style.backgroundColor = '';
            rotateBtn.style.backgroundColor = '';
            scaleBtn.style.backgroundColor = '';
            
            mode = newMode;
            button.style.backgroundColor = "yellow";

            if (newMode === 'translate') translation();
            if (newMode === 'rotate') rotation();
            if (newMode === 'scale') scaling();
        }

        translateBtn.addEventListener('click', () => setMode('translate', translateBtn));
        rotateBtn.addEventListener('click', () => setMode('rotate', rotateBtn));
        scaleBtn.addEventListener('click', () => setMode('scale', scaleBtn));


        // --- Utility and Drawing Functions ---
        
        const getShapeCenter = (pts) => {
            const calculationPoints = pts.slice(0, pts.length > 0 && pts[0].x === pts[pts.length-1].x && pts[0].y === pts[pts.length-1].y ? pts.length-1 : pts.length);
            if (calculationPoints.length === 0) return { x: 0, y: 0 };
            
            const sum = calculationPoints.reduce((acc, p) => {
                acc.x += p.x; acc.y += p.y;
                return acc
            }, {x:0, y:0})
            
            return {
                x: sum.x/calculationPoints.length,
                y: sum.y/calculationPoints.length
            }
        }

        // NEW: Generates all points for visualization (Vertices + Midpoints)
        function getStrokePoints(pts) {
            const uniquePoints = pts.slice(0, pts.length - 1); // Exclude the closing point
            if (uniquePoints.length < 2) return uniquePoints;
            
            let strokePoints = [];
            const N = uniquePoints.length;

            for (let i = 0; i < N; i++) {
                const p1 = uniquePoints[i];
                const p2 = uniquePoints[(i + 1) % N]; // Loop back to the first point
                
                // Add the vertex point
                strokePoints.push(p1);

                // Add the midpoint
                const midpoint = {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                };
                strokePoints.push(midpoint);
            }

            return strokePoints;
        }

        function drawShape() {
            ctx.clearRect(0,0, CANVAS_WIDTH, CANVAS_HEIGHT);
            if (points.length >= 3) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i< points.length ; i++)
                    ctx.lineTo(points[i].x, points[i].y)
                ctx.closePath();
                
                ctx.fillStyle = "orange";
                ctx.fill();
                ctx.strokeStyle = "black";
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.lineWidth = 1;
            }
        }

        function drawLines(){
            // Simplified drawing for the construction phase
            ctx.beginPath();
            ctx.moveTo(points[points.length - 2].x, points[points.length - 2].y);
            ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
            ctx.strokeStyle = "#D02152";
            ctx.stroke();
        }
        
        // --- Transformation Loops (Movement Logic) ---

        function translation(){
            function drawTrans(){
                if (mode !== 'translate') return;
                
                const angle = orientationValue * DEGREES_TO_RADIANS;
                let dx = speedValue * Math.cos(angle) / 60;
                let dy = speedValue * Math.sin(angle) / 60;
                
                points.map((pt) => {pt.x += dx; pt.y += dy});
                drawShape();
                drawVelocityArrows(); // Call visualization
                
                requestAnimationFrame(drawTrans);
            }
            drawTrans();
        }

        function rotation(){
            const center = getShapeCenter(points);

            function drawRotation() {
                if (mode != 'rotate') return;
                
                let angle = (speedValue / 60) * DEGREES_TO_RADIANS; 
                
                points.map((pt) => {
                    let translateX = pt.x - center.x;
                    let translateY = pt.y - center.y;
                    pt.x = center.x + (translateX * Math.cos(angle) - translateY * Math.sin(angle));
                    pt.y = center.y + (translateX * Math.sin(angle) + translateY * Math.cos(angle));
                });
                drawShape();
                drawVelocityArrows(); // Call visualization
                
                requestAnimationFrame(drawRotation);
            }
            drawRotation();
        }

        function scaling() {
            const center = getShapeCenter(points);
            function drawScale(){
                if (mode !== 'scale') return;
                
                const scaleFactor = 1 + speedValue / 6000; 
                
                points = points.map(pt => ({
                    x: center.x + (pt.x - center.x) * scaleFactor,
                    y: center.y + (pt.y - center.y) * scaleFactor  
                }));
                drawShape();
                drawVelocityArrows(); // Call visualization
                
                requestAnimationFrame(drawScale);
            } 
            drawScale();
        }

        // --- Velocity Visualization Functions ---

        // Helper function to calculate the 1-second displacement (dx, dy) for a single point
        function calculateDisplacement(p, center) {
            
            // 1-second total angle/factor, based on TIME_FACTOR = 1
            const totalAngle = speedValue * DEGREES_TO_RADIANS * TIME_FACTOR;
            const factor = 1 + (speedValue / 100) * TIME_FACTOR; 

            let dx = 0;
            let dy = 0;

            if (mode === 'translate') {
                const angle = orientationValue * DEGREES_TO_RADIANS;
                dx = speedValue * Math.cos(angle) * TIME_FACTOR; 
                dy = speedValue * Math.sin(angle) * TIME_FACTOR; 
            } else if (mode === 'rotate') {
                const x_rel = p.x - center.x;
                const y_rel = p.y - center.y;
                
                const x_prime = x_rel * Math.cos(totalAngle) - y_rel * Math.sin(totalAngle);
                const y_prime = x_rel * Math.sin(totalAngle) + y_rel * Math.cos(totalAngle);
                
                dx = x_prime - x_rel;
                dy = y_prime - y_rel;
            } else if (mode === 'scale') {
                const x_rel = p.x - center.x;
                const y_rel = p.y - center.y;
                
                dx = x_rel * (factor - 1);
                dy = y_rel * (factor - 1);
            }
            return { dx, dy };
        }

        // Replaced drawVelocityField with a stroke-focused visualization
        function drawVelocityArrows() {
            if (!hasDrawing || mode === 'none' || mode === 'drawing') return;

            // 1. Get the list of points to visualize (Vertices + Midpoints)
            const strokePoints = getStrokePoints(points);

            // 2. Get center for current iteration (it moves with the shape)
            let center = { x: 0, y: 0 };
            if (mode === 'rotate' || mode === 'scale') {
                center = getShapeCenter(points);
            }

            // 3. Determine arrow color
            let color = "red";
            if (mode === 'rotate' || mode === 'scale') {
                color = speedValue > 0 ? "green" : "red";
            }

            // 4. Iterate over the stroke points and draw the arrows
            strokePoints.forEach(p => {
                const disp = calculateDisplacement(p, center);
                drawArrow(ctx, p.x, p.y, disp.dx, disp.dy, color);
            });

            // 5. Draw the center marker on top
            if (mode === 'rotate' || mode === 'scale') {
                ctx.beginPath();
                ctx.arc(center.x, center.y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = "blue";
                ctx.fill();
            }
        }


        function drawArrow(ctx, x, y, dx, dy, color = "red") { 
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;

            const displacementLength = Math.sqrt(dx * dx + dy * dy);
            
            if (displacementLength < 0.1) return; 

            const arrowTipX = x + dx;
            const arrowTipY = y + dy;
            
            // Draw the line (tail to tip)
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(arrowTipX, arrowTipY);
            ctx.stroke();

            // --- Draw the arrowhead at the calculated tip ---
            const angle = Math.atan2(dy, dx);
            const headLength = 8; 
            const headAngle = Math.PI / 6; 

            // Draw one wing
            ctx.beginPath();
            ctx.moveTo(arrowTipX, arrowTipY);
            ctx.lineTo(
                arrowTipX - headLength * Math.cos(angle - headAngle),
                arrowTipY - headLength * Math.sin(angle - headAngle)
            );
            ctx.stroke();

            // Draw the other wing
            ctx.beginPath();
            ctx.moveTo(arrowTipX, arrowTipY);
            ctx.lineTo(
                arrowTipX - headLength * Math.cos(angle + headAngle),
                arrowTipY - headLength * Math.sin(angle + headAngle)
            );
            ctx.stroke();
            ctx.lineWidth = 1;
        }
        
        // --- FPS Monitoring ---
        let times = [];
        let fps = 0;
        let lastFpsUpdateTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            while (times.length > 0 && times[0] <= now - 1000) {
                times.shift();
            }
            times.push(now);
            fps = times.length;

            if (now - lastFpsUpdateTime >= 1000) {
                fpsBlock.textContent = `${fps}`;
                lastFpsUpdateTime = now;
            }
        }
        animate();
    </script>
</body>
</html>